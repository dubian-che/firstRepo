- [new和malloc](#new和malloc)
  - [动态内存分配](#动态内存分配)
  - [malloc 和 new的区别？](#malloc-和-new的区别)
    - [1.分配内存的位置](#1分配内存的位置)
    - [2.返回类型安全性](#2返回类型安全性)
    - [3.内存分配失败返回值](#3内存分配失败返回值)
    - [4.分配内存的大小的计算](#4分配内存的大小的计算)
    - [5.是否调用构造函数/析构函数](#5是否调用构造函数析构函数)
    - [6.对数组的处理](#6对数组的处理)
    - [7.new与malloc是否可以相互调用](#7new与malloc是否可以相互调用)
    - [8.是否可以被重载](#8是否可以被重载)
    - [9.分配内存时内存不足](#9分配内存时内存不足)
    - [总结](#总结)
    - [delete与delete []](#delete与delete-)
# new和malloc

一个由C/C++编译的程序占用的内存分为以下几个部分：
1、栈区（stack）— 由编译器自动分配释放 ，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束 时可能由OS回收 。分配方式类似于链表。
3、全局区（静态区）（static）—存放全局变量、静态数据、常量。程序结束后由系统释放。
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放。
5、程序代码区—存放函数体（类成员函数和全局函数）的二进制代码。

## 动态内存分配

在执行程序的过程中动态的分配或者回收存储空间的分配内存的方法。

例如：当我们在定义一个数组时，必须要用一个常量来确定在编译时分配多大的空间。但是在真正使用数组时，我们才会知道我们需要多少内存空间，所以我们要根据程序的需要即时分配，这就牵扯到内存的动态开辟。

C语言中
malloc、calloc、realloc、free

malloc:
void *malloc(unsigned int size)
开辟一块长度为size的连续内存空间，返回类型为void类型的指针。在使用malloc开辟一段空间时，void*要显示的转换为所需要的类型，如果开辟失败，则返回NULL指针。

calloc
void* calloc (size_t num, size_t size);
开辟一块num个大小为size的连续空间，并将每一块空间初始化为0。

realloc
void *realloc(void *ptr,size_t size);
将内存地址为ptr的一段空间的大小调整为size大小。

如果ptr这段空间后面有足够的空间，就直接追加上来
如果ptr后面的空间不足，则在堆上重新开辟一块合适大小的连续空间，将原有数据拷贝到新的内存空间中，释放掉原来的内存，最后返回的则是新地址。

free
void free (void* ptr);
free函数是来释放动态开辟的内存的。
malloc和free要配套使用，如果没有free则会造成内存泄漏。

alloc()从哪里获取的内存？

动态开辟的从堆里获取空间。就是说malloc函数返回的指针是指向堆里的一块内存。操作系统中有一个记录空闲内存地址的链表，当操作系统收到程序的申请时，就会遍历链表

C++中
new、delete

new
new运算返回所分配内存单元的起始地址，所以需要把返回值保存在一个指针变量中。若分配不成功，返回NULL，并抛出异常。
new没有为创建的对象命名，只能通过指针去访问对象或者数组。

delete
delete <指针变量>
delete []<动态分配的数组名>

new和delete必须配对使用。
虽然程序结束后系统会自动释放程序和其中数据所占的内存空间，但是为了在程序运行过程中能够重复使用有限的内存资源，防止系统产生内存泄漏，还是应该即时释放不需要的动态分配的内存单元，以便系统能随时对该内存单元进行分配。
delete释放内存，只是销毁内存上的对象，但是指针仍然存在，仍然指向原来的内存，保存原来空间的地址。所以我们应该在释放之后将指针置空，以避免后面不小心解引用造成问题。

例：

int *p1 = new int;
float *p2 = new float;

char *pBuffer = new char[100];
int *pA = new int[size];
student *stu = new student[num];

int *pNum = new int(100);


delete pNum;
delete []pBuffer;
1
2
3
4
5
6
7
8
9
10
11
12
## malloc 和 new的区别？

malloc/free是标准库函数，new/delete是C++运算符
malloc失败返回空，new失败抛异常
new/delete会调用构造、析构函数，malloc/free不会，所以他们无法满足动态对象的要求。
new返回有类型的指针，malloc返回无类型的指针
还有没有其他的理解？

### 1.分配内存的位置
malloc是从堆上动态分配内存，new是从自由存储区为对象动态分配内存。
自由存储区的位置取决于operator new的实现。自由存储区不仅可以为堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

### 2.返回类型安全性
malloc内存分配成功后返回void*，然后再强制类型转换为需要的类型；new操作符分配内存成功后返回与对象类型相匹配的指针类型；因此new是符合类型安全的操作符。

### 3.内存分配失败返回值
malloc内存分配失败后返回NULL；new分配内存失败则会抛异常（bac_alloc）。

try
{
int *a = new int();
}
catch (bad_alloc)
{
...
}

### 4.分配内存的大小的计算
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

### 5.是否调用构造函数/析构函数
使用new操作符来分配对象内存时会经历三个步骤：
- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
- 第三步：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：
- 第一步：调用对象的析构函数。
- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构；而malloc则不会。

### 6.对数组的处理
C++提供了new []和delete []用来专门处理数组类型。它会调用构造函数初始化每一个数组元素，然后释放对象时它会为每个对象调用析构函数，但是二者一定要配套使用；至于malloc，它并不知道你要在这块空间放置数组还是其他的东西，就只给一块原始的空间，再给一个内存地址就完事，如果要动态开辟一个数组的内存，还需要我们手动自定数组的大小。
A * ptr = new A[10];//分配10个A对象
delete [] ptr;
int * ptr = (int *) malloc( sizeof(int) * 10);//分配一个10个int元素的数组

### 7.new与malloc是否可以相互调用
operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new

### 8.是否可以被重载
opeartor new /operator delete可以被重载。而malloc/free则不能重载。

### 9.分配内存时内存不足
malloc动态分配内存后，如果不够用可以使用realloc函数重新分配实现内存的扩充；而new则没有这样的操作；

### 总结
将上面所述的10点差别整理成表格：

| 特征 | new/delete | malloc/free |
| --- | --- | ---|
| 分配内存的位置 | 自由存储区 | 堆 |
| 返回类型安全性 | 完整类型指针	| void* |
| 内存分配失败返回值 | 默认抛出异常	| 返回NULL |
| 分配内存的大小 | 由编译器根据类型计算得出 | 必须显式指定字节数 |
| 处理数组 | 有处理数组的new版本new[] | 需要用户计算数组的大小后进行内存分配 |
| 已分配内存的扩充 | 无法直观地处理 | 使用realloc简单完成 |
| 是否相互调用 | 可以，看具体的operator new/delete实现 | 不可调用new |
| 分配内存时内存不足 | 无法通过用户代码进行处理 | 能够使用realloc函数或重新制定分配器 |
| 函数重载 | 允许 | 不允许 |
| 构造函数与析构函数 | 调用 | 不调用 |

### delete与delete []

delete是回收new开辟出的单个对象指针指向的内存。
delete[]是回收new [] 开辟出的对象数组指针指向的内存。
new[]开辟数组空间要多出4个字节来存放数组大小。
delete []要与new []要配套使用

有了malloc/free为什么还要new/delete?

new运算不需要进行强制类型转换，使用简单方便；
new运算是通过调用构造函数初始化动态创建的对象，执行效率更高；
使用new能够进行异常处理，使用更安全
需要注意的问题：

如果你在函数上面定义了一个指针变量，然后在这个函数里申请了一块动态分配的内存让指针指向它。实际上，这个指针的地址是在栈上，但是它所指向的内容却是在堆上面。这一点要注意！所以，在一个函数里申请了空间后，比如：
void Function(void) 
{ 
      char *p = (char *)malloc(100 * sizeof(char)); 
}
1
2
3
4
千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了。这是错误的。因为申请的内存在堆上，除非程序员手动释放，否则要等到程序结束释放所有内存才会释放它们，跟函数是否结束没有关系。也就是函数所在的栈被销毁跟堆完全没有关系。所以，忠告就是：使用完不再需要记得释放动态分配的内存！在该部分程序退出之前释放内存并立即给P赋0值(NULL)。另一个办法是保证P在没有初始化之前，将不再被使用。
