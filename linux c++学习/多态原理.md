C++的多态是面向对象编程的核心，那么C++的多态是怎么来实现的？今天我们就来探讨一下。

从编译器的角度看：

C++编译器在编译时，会确定每个对象调用函数（非虚函数）的地址，这叫做早期绑定（也叫做静态绑定）。

当我们定义了派生类的对象，并取它的地址赋值给基类的指针，这时编译器会自动为派生类对象进行类型转换，将派生类对象转换为基类对象，站在内存的角度来看，访问的就是基类的成员。这是因为派生类的对象的对象模型如下：



基类的成员属于派生类成员的一部分，那么父类和子类的成员变量如何初始化呢？我们定义了Son的对象，编译器会自动调用Son的构造函数。在执行派生类的构造函数体之前，编译器会先调用父类的构造函数，先为父类的成员变量初始化，再为派生类的对象初始化，最后执行派生类构造函数的函数体。

当我们将Son 类对象转化为父类Father 类型时，该对象就被认为是派生类对象模型的上半部分，将该对象当成父类对象执行相应的代码，自然就调用父类的函数了。

那么，真正的C++多态是什么呢？

C++实现多态的机制很简单，在继承体系下，将父类的某个函数给成虚函数（即加上virtual关键字），在派生类中对这个虚函数进行重写，利用父类的指针或引用调用虚函数。

当我们将函数声明为virtual 时，编译器不会在编译时就确定对象要调用的函数的地址，而是在运行时再去确定要调用的函数的地址，这就是晚绑定，也叫做动态绑定。



第一：编译器在发现Father 类中有虚函数时，会自动为每个含有虚函数的类生成一份虚函数表，也叫做虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址。

第二：编译器会在每个对象的前四个字节中保存一个虚表指针，即（vptr),指向对象所属类的虚表。在程序运行时的合适时机，根据对象的类型去初始化vptr，从而让vptr指向正确的虚表，从而在调用虚函数时，能找到正确的函数。

第三：所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。

总结：

（1）C++的多态性是通过晚绑定（动态绑定）技术实现的。

（2）含有虚函数的类都有虚表。

（3）当子类对父类的虚函数没有重写时，子类的虚表指针保存的是父类的虚表；当子类对父类的虚函数重写时，子类的虚表指针保存的是子类的虚表；当子类中有自己的虚函数时，在虚表中将此虚函数地址添加在后面。

c++的多态性用一句话概括就是:在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。
