析构函数virtual与非virtual区别
作为通常的原则，如果一个类定义了虚函数，那么它的析构函数就应当是virtual的。因为定义了虚函数则隐含着：这个类会被继承，并且会通过基类的指针指向子类对象，从而得到多态性。   这个类可能会被继承，并且会通过基类的指针指向子类对象”，因此基类的析构函数是否为虚将决定子类的对象是否被析构

示例代码：
```c++
#include <iostream.h>

struct A
{
    virtual ~A() {cout<<"~A()\n";}
};

struct B: public A
{
    ~B() {cout<<"~B()\n";}
};

void main()
{
    A* p = new B;
    delete p;
}
```

如果 A的析构函数不是virtual的，那么此时就不是先调用B的析构函数再调用A的析构函数。
Output:
~A(); 
如果A   的析构函数为virtual，则先~B()，再~A()  
Output:
~B();
~A();
       类如果会被派生的话，析构函数一般都应该定义为virtual的，主要不是防止内存泄露，而是为了正确的析构。如果是个封闭类（即不再被派生），就不要定义为virtual的。虚函数毕竟耗费较大的。

不用virtual 的几种情况：
  1、作为非公有基类。仅作为   private   base   class   使用的   class   不需要使用虚拟析构函数  
  2、不作为接口使用的基类。  
  3.   如果你可以保证这个类不被public继承（private/protected继承的话，在非friend函数/类中就无法用基类指针指向派生类了）  
  4.   如果它的所有派生类（包括派生类的派生类）的析构函数都是trivial的（这里的trivial指的是在程序员的层次什么事也不做）  
  5.   如果不需要用基类的指针指向派生类的对象  
  在这五种情况下，不把析构函数声明为virtual都是可以的，何况效率会高一些——但前提是你得保证前提的成立——不过这些保证常常是很难100％的：谁能保证别人在派生你的类的时候，析构函数是trivial的，或者别人不用你提供的基类的指针指向派生类对象？这些常常是很难得到保证的。  

声明基类的析构函数为virtual并非总是为了防止memory   leak   另外这也只是作为一般的原则（基类中有虚函数则把其析构函数声明为virtual）。如果你的析构函数什么事也不作，从效果上来说，不声明为virtual也无妨